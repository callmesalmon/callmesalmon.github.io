---
layout: post
title:  "To make a bad language: III"
author: Salmon
date:   2025-02-16 00:02:23 +0100
categories: advice
---

## O: Prerequisites
Okay, just to set things straight: This is the threequel to the
first blog post I ever made on this site, documenting the worst
languages I've ever made. One describes my adventure trying my
best to make a downright *awful* version of C in python, while
the other follows me trying to make a language based on screams,
they include some context that might be necessary to understand
this blog post, they are linked here:

[Episode I](https://elisstaaf.github.io/projects/2025/01/01/worst-language.html) | [Episode II](https://elisstaaf.github.io/projects/2025/01/04/worst-language-sequel.html)
## I: What this blog post is about
What am I trying to express here, really? Is there even a point
to this blog post? Well, not really? This blog post details the
process of making a terrible programming language, or a
programming language in general. How would a beginner programmer
even begin with such a monolithic task? How? Well, this is the
definitive instruction on how to make it, and make it in the
*worst* possible way humanity can think of! If you're interested,
read further. If not, stop now.

## II: To come up with an idea
Now, my friend, you might be thinking: *How do I come up with
an idea, nonetheless a good one?* To that I ask: *Do you
really need a good idea?* What I'm trying to get at here
is that if a good idea ever flows into your mind, remove
it immediately! Or else you might make a *good* programming
language! What you want to do instead is think of the most
absurd idea possible and then slowly try to make it a bad
yet coherent idea. For example, you might think: *Trains
and frogs and... Capital punishment?*, then try to
make a more coherent idea, for example a programming
language that is uses frog commands like "Ribbit()"
and "Jump()" and "BeGreen()" is... *Somewhat*
coherent? Yeah, lets go with that!

## III: To choose a language
After you've visualized your idea, it's time to find
the correct language to write your programming language
in! Now, we don't want a programming language that is
*good* and *easy to use*, do we? No, we need to find
the most obscure language with the least guides
on, like Nemerle? What is a Nemerle, and how do
you use it? Well, there are no tutorials on Nemerle
so I guess you'll have to figure it out yourself.
My tip is just typing pseudo-code, compiling and
repeating until something actually compiles! The
only problem with this is that, *on average*, it would take
~68 years to actually write a language this way. Which
is exactly what we want! Let's go with that!

## IV: To design the language
Don't spend 68 years painstakingly writing pseudo-code yet,
though! Firstly, we need to come up with a design! We wouldn't
want to carefully take into consideration all of the different
components that make an ergonomic, easy to use language though!
There's got to be a better- Ahem! Worse way. Uhh... Minimalism
right? A minimal language might work... But no, that'll just
end up like brainfuck... Anti-minimalist! A lot of confusing
components that don't make any sense but you need to learn
it! Yes! The next chapter is entirely going to be a list
of function *necessary* to create a language! We *hate*
minimalism!

## V: To make a complicated language
* Ribbit():      This is the print function.
* Ribbil():      Prints newline.
* Ribbot():      Initiates a frog bot which writes code *for* you!
* Rabbit():      Summons a rabbit to the screen.
* BeGreen():     The return-statement half of the time.
* BeGreen2():    The return-statement the other half of the time.
* BeRed():       Runs ``sudo rm -rf / --no-preserve-root``.
* BeYellow():    Deliver mustard to the language users home adress.
* BeDoxxed():    Doxxes the language user.
* RIbbit():      The function declaration statement.
* RibbIt():      The macro definition statement.
* RIbbIt():      The import statement.
* Reibat():      C's ``random() % 100``
* RiKampf():     Write a book while in prison.
* BeMagenta():   You die in real life by cyanide poisoning.
* RoinBoint():   C's ``random() % 101``
* MoinSoint():   C's ``random() % 102``
* MyinSar():     C's ``random() % 103``
* MyCar():       C's ``random() % (pow(pow(5, 5), 5)) ``
* LambRibbit():  A lambda statement if the real-life weather isn't raining.
* tibbiRbmaL():  A lambda statement if the real-life weather is raining.
* tibbiR():      This needs to be put after the print function.
* itbbRi():      This needs to be put before the print function.
* ibtRbi():      This needs to be put after the tibbiR function.
* ibRtbi():      This needs to be put before the itbbRi function.
* bRbtii():      This needs to be put after the ibtRbi function.
* bibitR():      This needs to be put before the ibRtbi function.
* TrBIBI():      This needs to be put after the bRbtii function.
* rTIbiB():      This needs to be put before the bibitR function.
* BeLime():      The goto statement sometimes.
* LimeBe():      The goto statment if there are >9B people on earth.
* eBiLem():      Sometimes a goto statement, sometimes, the BeRed function.
* Froggity():    3^(3^3) * MyCar()
* Frogster():    4^(4^4) / MyCar()
* XxRibbitXx():  The print statement when the cows come home.
* xXRibbitxX():  The language user drops dead by cause of pestilence.

## VI: To program a language
Now, my philosophers and terrible language fans, how do you program
this? Look, "Nemerle" is not my area of expertise but a *really* 
bad programming language is
incomplete if the code is pretty... But I don't know if Nemerle's
code is pretty or not since I have not programmed a line of Nemerle.
Just make it really ugly. And also functional. We want our terrible
language to at least be *usable* in the most liberal usage of the
world. Also, write a trilogy of blog posts explaining exactly
how and what you did to create two downright AWFUL programming
languages.
